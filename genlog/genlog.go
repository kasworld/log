// Copyright 2015,2016,2017,2018,2019,2020 SeukWon Kang (kasworld@gmail.com)
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var (
	packagename    = flag.String("packagename", "", "packagename")
	leveldatafile  = flag.String("leveldatafile", "", "leveldatafile")
	outputfilename = "log_gen.go"
)

func MakeGenComment() string {
	return fmt.Sprintf(
		"// Code generated by \"%s %s\" \n",
		filepath.Base(os.Args[0]),
		strings.Join(os.Args[1:], " "))

}

func isDir(path string) error {
	finfo, staterr := os.Stat(path)
	if staterr != nil {
		return staterr
	}
	if !finfo.IsDir() {
		return fmt.Errorf("invalid dir: %v", path)
	}
	return nil
}

// loadEnumWithComment load list of enum + comment
func loadEnumWithComment(filename string) ([][]string, error) {
	fd, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fd.Close()
	rtn := make([][]string, 0)
	rd := bufio.NewReader(fd)
	for {
		line, err := rd.ReadString('\n')
		line = strings.TrimSpace(line)
		if len(line) != 0 {
			s2 := strings.SplitN(line, " ", 2)
			if len(s2) == 1 {
				s2 = append(s2, "")
			}
			rtn = append(rtn, s2)
		}
		if err != nil { // eof
			break
		}
	}
	return rtn, nil
}

func SaveTo(outdata *bytes.Buffer, outfilename string) error {
	src, err := format.Source(outdata.Bytes())
	if err != nil {
		fmt.Println(outdata)
		return err
	}
	if werr := ioutil.WriteFile(outfilename, src, 0644); werr != nil {
		return werr
	}
	return nil
}

func main() {
	flag.Parse()

	if *packagename == "" {
		fmt.Printf("packagename not set\n")
		return
	}
	if *leveldatafile == "" {
		fmt.Printf("leveldatafile not set\n")
		return
	}

	leveldata, err := loadEnumWithComment(*leveldatafile)
	if err != nil {
		fmt.Printf("%v", err)
		return
	}

	buf, err := Build(*packagename, leveldata)
	if err != nil {
		fmt.Printf("%v", err)
		return
	}

	if err := SaveTo(buf, *packagename+"/"+outputfilename); err != nil {
		fmt.Printf("%v\n", err)
	}
}

func Build(packagename string, leveldata [][]string) (*bytes.Buffer, error) {

	var buff bytes.Buffer

	fmt.Fprintln(&buff, MakeGenComment())
	fmt.Fprintf(&buff, `
	package %[1]s
	import (
		"bytes"
		"fmt"
		"path/filepath"
		"strconv"
		"sync"
		"time"
	
		"github.com/kasworld/log/logdestination_stdio"
		"github.com/kasworld/log/logdestinationgroup"
		"github.com/kasworld/log/logdestinationi"
		"github.com/kasworld/log/logflagi"
	)
	`,
		packagename)

	fmt.Fprintf(&buff, `
	type LL_Type uint64
	func (ll LL_Type) LevelsString() string {
		var buff bytes.Buffer
		buff.WriteString("LL_Type[")
		for ll := LL_Type(1); ll < LL_END; ll <<= 1 {
			if ll.IsLevel(ll) {
				fmt.Fprintf(&buff, "%%s, ", ll)
			}
		}
		buff.WriteString("]")
		return buff.String()
	}
	func (ll LL_Type) String() string {
		if str, ok := leveldata[ll]; ok {
			return str
		}
		return "LL_Type(" + strconv.FormatInt(int64(ll), 10) + ")"
	}
	func (ll LL_Type) IsLevel(l2 LL_Type) bool {
		return ll&l2 != 0
	}
	func (ll LL_Type) StartLevel() LL_Type {
		return LL_Fatal
	}
	func (ll LL_Type) IsLastLevel() bool {
		return ll == LL_END
	}
	func (ll LL_Type) NextLevel(n uint) LL_Type {
		return ll << n
	}
	func (ll LL_Type) PreLevel(n uint) LL_Type {
		return ll >> n
	}
	func (ll LL_Type) BitAnd(l2 LL_Type) LL_Type {
		return ll & l2
	}
	func (ll LL_Type) BitOr(l2 LL_Type) LL_Type {
		return ll | l2
	}
	func (ll LL_Type) BitXor(l2 LL_Type) LL_Type {
		return ll ^ l2
	}
	func (ll LL_Type) BitClear(l2 LL_Type) LL_Type {
		return ll &^ l2
	}
	func (ll LL_Type) BitTest(l2 LL_Type) bool {
		return ll&l2 != 0
	}
	func (ll LL_Type) TestAt(n int) bool {
		return ll&LL_Type(1<<n) != 0
	}
	const (
	`,
	)
	for i, lvname := range leveldata {
		if i == 0 {
			fmt.Fprintf(&buff, "LL_%v LL_Type = 1 << iota // %v\n", lvname[0], lvname[1])
		} else {
			fmt.Fprintf(&buff, "LL_%v // %v\n", lvname[0], lvname[1])
		}
	}
	fmt.Fprintf(&buff, `
	LL_END
	LL_All = LL_END - 1
	LL_Count = %v
	)`, len(leveldata))

	fmt.Fprintf(&buff, `
	var leveldata = map[LL_Type]string{
	`)

	for i, lvname := range leveldata {
		fmt.Fprintf(&buff, "%v : \"%v\", \n", 1<<uint(i), lvname[0])
	}
	fmt.Fprintf(&buff, `
	%v : "%v",
	}
	//////////////////////////////////////////////////////////////////
	`, 1<<uint(len(leveldata)), "END")

	fmt.Fprintf(&buff, `
	var (
		OutputStdout = logdestination_stdio.NewStdOut()
		OutputStderr = logdestination_stdio.NewStdErr()
	)
	
	//////////////////////////////////////////////////////////////////
	
	type logDestInfo struct {
		refCntByLogLv int // count referenced by each loglv
		dest          logdestinationi.LogDestinationI
	}
	
	type LogBase struct {
		mutex sync.RWMutex
	
		flag     logflagi.LogFlagI // properties
		prefix   string            // prefix to write at beginning of each line
		loglevel LL_Type
	
		ltype2destgrp     []*logdestinationgroup.LogDestinationGroup
		allDestInfoByName map[string]*logDestInfo
	}
	
	func New(prefix string, lf logflagi.LogFlagI, lv LL_Type) *LogBase {
	
		dstgrp := make([]*logdestinationgroup.LogDestinationGroup, LL_Count)
		for i := 0; i < LL_Count; i++ {
			dstgrp[i] = logdestinationgroup.New()
		}
	
		return &LogBase{
			ltype2destgrp:     dstgrp,
			allDestInfoByName: make(map[string]*logDestInfo),
			flag:              lf,
			prefix:            prefix,
			loglevel:          lv,
		}
	}
	
	func makeLogFilename(logdir string, ll string) string {
		basename := filepath.Base(logdir)
		filename := fmt.Sprintf("%%s.%%s.%%s", basename, ll, "log")
		return filepath.Join(logdir, filename)
	}
	func (lg *LogBase) AddDestination(
		ll LL_Type, o logdestinationi.LogDestinationI) {
	
		lg.mutex.Lock()
		defer lg.mutex.Unlock()
		for i := 0; i < LL_Count; i++ {
			if ll.TestAt(i) {
				lg.addDestination1DestGrp(i, o)
			}
		}
	}
	
	func (lg *LogBase) addDestination1DestGrp(
		i int, o logdestinationi.LogDestinationI) {
	
		added := lg.ltype2destgrp[i].AddDestination(o)
		if !added {
			if _, ok := lg.allDestInfoByName[o.Name()]; !ok {
				panic(fmt.Sprintf(
					"%%v failed to AddDestination to destgroup index:%%v, abnormal state",
					lg, i))
			}
			fmt.Printf("%%v not added to destgroup index:%%v\n", o, i)
			return
		}
	
		if dstinfo, ok := lg.allDestInfoByName[o.Name()]; ok {
			dstinfo.refCntByLogLv++
		} else {
			lg.allDestInfoByName[o.Name()] = &logDestInfo{
				refCntByLogLv: 1,
				dest:          o,
			}
		}
	}
	
	func (lg *LogBase) DelDestination(
		ll LL_Type, o logdestinationi.LogDestinationI) {
	
		lg.mutex.Lock()
		defer lg.mutex.Unlock()
		for i := 0; i < LL_Count; i++ {
			if ll.TestAt(i) {
				lg.delDestinationFrom1DestGrp(i, o)
			}
		}
	}
	
	func (lg *LogBase) delDestinationFrom1DestGrp(
		i int, o logdestinationi.LogDestinationI) {
	
		deleted := lg.ltype2destgrp[i].DelDestination(o)
		if !deleted {
			fmt.Printf("%%v not deleted from destgroup index:%%v\n", o, i)
			return
		}
	
		if dstinfo, ok := lg.allDestInfoByName[o.Name()]; ok {
			dstinfo.refCntByLogLv--
			if dstinfo.refCntByLogLv <= 0 {
				delete(lg.allDestInfoByName, o.Name())
			}
		} else {
			panic(fmt.Sprintf(
				"%%v failed to DelDestination %%v from destgroup index:%%v, abnormal state",
				lg, o, i,
			))
		}
	}
	
	func (lg *LogBase) Reload() error {
		lg.mutex.RLock()
		defer lg.mutex.RUnlock()
	
		for _, v := range lg.allDestInfoByName {
			if err := v.dest.Reload(); err != nil {
				fmt.Println(err)
			}
		}
		return nil
	}
	
	func (lg *LogBase) LogPrintf(calldepth int, ll LL_Type,
		format string, v ...interface{}) ([]byte, error) {
		s := lg.Format2Bytes(calldepth+1, ll, format, v...)
		err := lg.Output(ll, s)
		return s, err
	}
	
	func (lg *LogBase) Format2Bytes(calldepth int, ll LL_Type,
		format string, v ...interface{}) []byte {
	
		if !lg.loglevel.IsLevel(ll) {
			return nil
		}
		s := fmt.Sprintf(format, v...)
		var buf []byte
		llinfo := fmt.Sprintf("%%s", ll)
		lg.flag.FormatHeader(&buf, calldepth+2, time.Now(), lg.prefix, llinfo)
		buf = append(buf, s...)
		if len(s) == 0 || s[len(s)-1] != '\n' {
			buf = append(buf, '\n')
		}
		return buf
	}
	
	func (lg *LogBase) Output(ll LL_Type, b []byte) error {
		var err error
		for i := 0; i < LL_Count; i++ {
			if ll.TestAt(i) {
				if lerr := lg.ltype2destgrp[i].Write(b); lerr != nil {
					err = lerr
				}
			}
		}
		return err
	}
	
	func (lg *LogBase) SetLevel(level LL_Type) {
		lg.mutex.Lock()
		defer lg.mutex.Unlock()
		lg.loglevel = level
	}
	
	func (lg *LogBase) GetLevel() LL_Type {
		return lg.loglevel
	}
	
	func (lg *LogBase) SetPrefix(p string) {
		lg.mutex.Lock()
		defer lg.mutex.Unlock()
		lg.prefix = p
	}
	
	// Prefix returns the output prefix for the logger.
	func (lg *LogBase) GetPrefix() string {
		return lg.prefix
	}
	
	// Flags returns the output flags for the logger.
	func (lg *LogBase) GetFlags() logflagi.LogFlagI {
		return lg.flag
	}
	
	// SetFlags sets the output flags for the logger.
	func (lg *LogBase) SetFlags(flag logflagi.LogFlagI) {
		lg.mutex.Lock()
		defer lg.mutex.Unlock()
		lg.flag = flag
	}
	
	func (lg *LogBase) String() string {
		return fmt.Sprintf("LogBase[%%v %%v]",
			lg.flag.FlagString(), lg.loglevel.LevelsString(),
		)
	}
	`)
	for _, lvname := range leveldata {
		fmt.Fprintf(&buff, `
		func (l *LogBase) %[1]s(format string, v ...interface{}) {
			if !l.GetLevel().IsLevel(LL_%[1]s) {
				return
			}
			s := l.Format2Bytes(1, LL_%[1]s, format, v...)
			err := l.Output(LL_%[1]s,s)
			if err != nil {
				fmt.Println(err)
			}
		}
		`, lvname[0],
		)
	}
	fmt.Fprintf(&buff, `
	//////////////////////////////////////////////////////////////////
	var GlobalLogger *LogBase
	`)
	for _, lvname := range leveldata {
		fmt.Fprintf(&buff, `
		func %[1]s(format string, v ...interface{}) {
			if !GlobalLogger.GetLevel().IsLevel(LL_%[1]s) {
				return
			}
			s := GlobalLogger.Format2Bytes(1, LL_%[1]s, format, v...)
			err := GlobalLogger.Output(LL_%[1]s,s)
			if err != nil {
				fmt.Println(err)
			}
		}
		`, lvname[0],
		)
	}
	return &buff, nil
}
